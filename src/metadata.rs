//! # Blueprint Node Metadata
//!
//! Integration with pulsar_std's node registry system.
//!
//! This module provides access to Blueprint node metadata through the
//! compile-time registry generated by the `#[blueprint]` macro in pulsar_std.

use graphy::core::{NodeMetadata, NodeMetadataProvider, ParamInfo, TypeInfo};
use std::collections::HashMap;
use std::sync::OnceLock;

/// Cached node metadata from pulsar_std
static NODE_METADATA: OnceLock<HashMap<String, NodeMetadata>> = OnceLock::new();

/// Convert pulsar_std NodeMetadata to Graphy NodeMetadata
fn convert_node_metadata(ps_node: &pulsar_std::registry::NodeMetadata) -> NodeMetadata {
    // Convert node type (the enums match, so we can convert via string representation)
    let node_type = match ps_node.node_type {
        pulsar_std::NodeTypes::pure => graphy::NodeTypes::pure,
        pulsar_std::NodeTypes::fn_ => graphy::NodeTypes::fn_,
        pulsar_std::NodeTypes::control_flow => graphy::NodeTypes::control_flow,
        pulsar_std::NodeTypes::event => graphy::NodeTypes::event,
    };

    // Convert parameters
    let params: Vec<ParamInfo> = ps_node
        .params
        .iter()
        .map(|p| ParamInfo::new(p.name, p.ty))
        .collect();

    // Convert return type
    let return_type = ps_node
        .return_type
        .map(|ty| TypeInfo::new(ty.to_string()));

    // Convert exec outputs
    let exec_outputs: Vec<String> = ps_node
        .exec_outputs
        .iter()
        .map(|s| s.to_string())
        .collect();

    // Convert imports - flatten NodeImport into simple import strings
    let imports: Vec<String> = ps_node
        .imports
        .iter()
        .map(|import| {
            if import.items.is_empty() {
                format!("use {};", import.crate_name)
            } else {
                format!("use {}::{{{}}};", import.crate_name, import.items.join(", "))
            }
        })
        .collect();

    NodeMetadata::new(ps_node.name, node_type, ps_node.category)
        .with_params(params)
        .with_return_type(return_type.unwrap_or_else(|| TypeInfo::new("()".to_string())))
        .with_exec_outputs(exec_outputs)
        .with_imports(imports)
        .with_source(ps_node.function_source)
}

/// Extract all node metadata from the pulsar_std registry
///
/// This function accesses the registry built by the `#[blueprint]` macro processor
/// during compilation of pulsar_std. The registry contains all Blueprint-compatible
/// functions with their metadata pre-parsed and validated.
///
/// # Returns
///
/// * `Ok(HashMap)` - Map of node names to their metadata
/// * `Err(String)` - Error message if registry is unavailable
///
/// # Thread Safety
///
/// This function is thread-safe. The registry is built at compile time and stored
/// in static memory, so multiple threads can access it concurrently without locks.
pub fn extract_node_metadata() -> Result<HashMap<String, NodeMetadata>, String> {
    let ps_nodes = pulsar_std::get_all_nodes();
    
    let mut metadata = HashMap::new();
    for ps_node in ps_nodes {
        let node = convert_node_metadata(ps_node);
        metadata.insert(node.name.clone(), node);
    }

    Ok(metadata)
}

/// Get cached node metadata, initializing if necessary
///
/// This function provides thread-safe, lazy initialization of node metadata.
/// The metadata is extracted from pulsar_std on first call and cached for
/// all subsequent calls.
pub fn get_node_metadata() -> &'static HashMap<String, NodeMetadata> {
    NODE_METADATA.get_or_init(|| {
        match extract_node_metadata() {
            Ok(metadata) => {
                tracing::info!("[PBGC] Loaded {} node definitions from pulsar_std", metadata.len());
                metadata
            }
            Err(e) => {
                tracing::error!("[PBGC] Failed to extract node metadata: {}", e);
                HashMap::new()
            }
        }
    })
}

/// Blueprint metadata provider
///
/// Implements the `NodeMetadataProvider` trait for Blueprint nodes.
pub struct BlueprintMetadataProvider {
    metadata: &'static HashMap<String, NodeMetadata>,
}

impl BlueprintMetadataProvider {
    pub fn new() -> Self {
        Self {
            metadata: get_node_metadata(),
        }
    }
}

impl Default for BlueprintMetadataProvider {
    fn default() -> Self {
        Self::new()
    }
}

impl NodeMetadataProvider for BlueprintMetadataProvider {
    fn get_node_metadata(&self, node_type: &str) -> Option<&NodeMetadata> {
        self.metadata.get(node_type)
    }

    fn get_all_nodes(&self) -> Vec<&NodeMetadata> {
        self.metadata.values().collect()
    }

    fn get_nodes_by_category(&self, category: &str) -> Vec<&NodeMetadata> {
        self.metadata
            .values()
            .filter(|m| m.category == category)
            .collect()
    }
}

/// Get nodes organized by category
///
/// Returns a map from category names to lists of nodes in that category.
/// Useful for building the node palette in the visual editor.
pub fn get_nodes_by_category() -> HashMap<String, Vec<&'static NodeMetadata>> {
    let mut categorized: HashMap<String, Vec<&'static NodeMetadata>> = HashMap::new();
    let metadata = get_node_metadata();

    for node in metadata.values() {
        categorized
            .entry(node.category.clone())
            .or_insert_with(Vec::new)
            .push(node);
    }

    categorized
}

/// Get all available node categories
///
/// Returns a sorted list of all category names in the registry.
pub fn get_categories() -> Vec<String> {
    let metadata = get_node_metadata();
    let mut categories: Vec<String> = metadata
        .values()
        .map(|m| m.category.clone())
        .collect::<std::collections::HashSet<_>>()
        .into_iter()
        .collect();

    categories.sort();
    categories
}

/// Find a node by name
pub fn find_node(name: &str) -> Option<&'static NodeMetadata> {
    get_node_metadata().get(name)
}
