//! # Blueprint Node Metadata
//!
//! Integration with pulsar_std's node registry system.
//!
//! This module provides access to Blueprint node metadata through the
//! compile-time registry generated by the `#[blueprint]` macro in pulsar_std.

use graphy::core::{NodeMetadata, NodeMetadataProvider};
use std::collections::HashMap;
use std::sync::OnceLock;

/// Cached node metadata from pulsar_std
static NODE_METADATA: OnceLock<HashMap<String, NodeMetadata>> = OnceLock::new();

/// Extract all node metadata from the pulsar_std registry
///
/// This function accesses the registry built by the `#[blueprint]` macro processor
/// during compilation of pulsar_std. The registry contains all Blueprint-compatible
/// functions with their metadata pre-parsed and validated.
///
/// # Returns
///
/// * `Ok(HashMap)` - Map of node names to their metadata
/// * `Err(String)` - Error message if registry is unavailable
///
/// # Thread Safety
///
/// This function is thread-safe. The registry is built at compile time and stored
/// in static memory, so multiple threads can access it concurrently without locks.
///
/// # Note
///
/// In production, this function would call `pulsar_std::get_all_nodes()`.
/// For development/testing without pulsar_std, this returns a mock registry.
pub fn extract_node_metadata() -> Result<HashMap<String, NodeMetadata>, String> {
    // TODO: Replace with actual pulsar_std integration
    // let nodes = pulsar_std::get_all_nodes();

    // For now, return an empty map as a placeholder
    // In production, this would extract from pulsar_std
    Ok(HashMap::new())
}

/// Get cached node metadata, initializing if necessary
///
/// This function provides thread-safe, lazy initialization of node metadata.
/// The metadata is extracted from pulsar_std on first call and cached for
/// all subsequent calls.
pub fn get_node_metadata() -> &'static HashMap<String, NodeMetadata> {
    NODE_METADATA.get_or_init(|| {
        match extract_node_metadata() {
            Ok(metadata) => {
                tracing::info!("[PBGC] Loaded {} node definitions from pulsar_std", metadata.len());
                metadata
            }
            Err(e) => {
                tracing::error!("[PBGC] Failed to extract node metadata: {}", e);
                HashMap::new()
            }
        }
    })
}

/// Blueprint metadata provider
///
/// Implements the `NodeMetadataProvider` trait for Blueprint nodes.
pub struct BlueprintMetadataProvider {
    metadata: &'static HashMap<String, NodeMetadata>,
}

impl BlueprintMetadataProvider {
    pub fn new() -> Self {
        Self {
            metadata: get_node_metadata(),
        }
    }
}

impl Default for BlueprintMetadataProvider {
    fn default() -> Self {
        Self::new()
    }
}

impl NodeMetadataProvider for BlueprintMetadataProvider {
    fn get_node_metadata(&self, node_type: &str) -> Option<&NodeMetadata> {
        self.metadata.get(node_type)
    }

    fn get_all_nodes(&self) -> Vec<&NodeMetadata> {
        self.metadata.values().collect()
    }

    fn get_nodes_by_category(&self, category: &str) -> Vec<&NodeMetadata> {
        self.metadata
            .values()
            .filter(|m| m.category == category)
            .collect()
    }
}

/// Get nodes organized by category
///
/// Returns a map from category names to lists of nodes in that category.
/// Useful for building the node palette in the visual editor.
pub fn get_nodes_by_category() -> HashMap<String, Vec<&'static NodeMetadata>> {
    let mut categorized: HashMap<String, Vec<&'static NodeMetadata>> = HashMap::new();
    let metadata = get_node_metadata();

    for node in metadata.values() {
        categorized
            .entry(node.category.clone())
            .or_insert_with(Vec::new)
            .push(node);
    }

    categorized
}

/// Get all available node categories
///
/// Returns a sorted list of all category names in the registry.
pub fn get_categories() -> Vec<String> {
    let metadata = get_node_metadata();
    let mut categories: Vec<String> = metadata
        .values()
        .map(|m| m.category.clone())
        .collect::<std::collections::HashSet<_>>()
        .into_iter()
        .collect();

    categories.sort();
    categories
}

/// Find a node by name
pub fn find_node(name: &str) -> Option<&'static NodeMetadata> {
    get_node_metadata().get(name)
}
